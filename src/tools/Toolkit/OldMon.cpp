#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif // IMGUI_DEFINE_MATH_OPERATORS

#include "OldMon.h"

#include <iostream>
#include <cctype>
#include <set>
#include <string>
#include <Exd/ExdData.h>
#include <Exd/Structs.h>

#include "EditorState.h"

#include "Engine/GfxApi.h"
#include "Engine/ResourceManager.h"
#include "Engine/ShaderResource.h"


#include "imgui.h"
#include <random>
#include <vector>

#include "Engine/Input.h"
#include "Engine/Service.h"
#include "Engine/Logger.h"

#include <math.h>
#include <vector>

#include <algorithm>
#include <unordered_set>
#include <glm/gtx/matrix_decompose.hpp>

#include "Application.h"

#include "Service.h"
#include <algorithm>
#include <cctype>

#include "Common.h"
#include "PreparedResultSet.h"

#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/type_ptr.hpp"
#include <GL/glew.h>

#include "imgui_internal.h"
#include "Util/Paths.h"

extern Sapphire::Db::DbWorkerPool< Sapphire::Db::ZoneDbConnection > g_charaDb;


OldMon::OldMon()
{
  // Set config file path
  auto executableDir = Sapphire::Common::Util::executableDir();
  m_configFile = executableDir / "oldmon_config.txt";

  loadConfig(); // Load config first
  initDbConfigBuffers();
}

OldMon::~OldMon()
{
}

void OldMon::init()
{
  loadConfig(); // Load config first
  initDbConfigBuffers();
  connectToDatabase();

  if( m_dbConnectionOpen )
  {
    loadVersions();
  }
}

void OldMon::loadConfig()
{
  std::ifstream configFile( m_configFile );
  if( !configFile.is_open() )
  {
    // Use default values if config file doesn't exist
    return;
  }

  std::string line;
  while( std::getline( configFile, line ) )
  {
    size_t pos = line.find( '=' );
    if( pos != std::string::npos )
    {
      std::string key = line.substr( 0, pos );
      std::string value = line.substr( pos + 1 );

      // Trim whitespace
      key.erase( 0, key.find_first_not_of( " \t" ) );
      key.erase( key.find_last_not_of( " \t" ) + 1 );
      value.erase( 0, value.find_first_not_of( " \t" ) );
      value.erase( value.find_last_not_of( " \t" ) + 1 );

      if( key == "db_host" )
      {
        m_dbConnectionInfo.host = value;
      }
      else if( key == "db_user" )
      {
        m_dbConnectionInfo.user = value;
      }
      else if( key == "db_password" )
      {
        m_dbConnectionInfo.password = value;
      }
      else if( key == "db_database" )
      {
        m_dbConnectionInfo.database = value;
      }
      else if( key == "db_port" )
      {
        try
        {
          m_dbConnectionInfo.port = std::stoi( value );
        } catch( const std::exception& )
        {
          m_dbConnectionInfo.port = 3306; // Default port
        }
      }
    }
  }

  configFile.close();
  printf( "Loaded OldMon config from: %s\n", m_configFile.string().c_str() );
}

void OldMon::saveConfig()
{
  std::ofstream configFile( m_configFile );
  if( !configFile.is_open() )
  {
    printf( "Failed to create OldMon config file: %s\n", m_configFile.string().c_str() );
    return;
  }

  configFile << "# OldMon Database Configuration" << std::endl;
  configFile << "# This file is automatically generated" << std::endl;
  configFile << std::endl;

  configFile << "# Database Connection Settings" << std::endl;
  configFile << "db_host=" << m_dbConnectionInfo.host << std::endl;
  configFile << "db_user=" << m_dbConnectionInfo.user << std::endl;
  configFile << "db_password=" << m_dbConnectionInfo.password << std::endl;
  configFile << "db_database=" << m_dbConnectionInfo.database << std::endl;
  configFile << "db_port=" << m_dbConnectionInfo.port << std::endl;

  configFile.close();
  printf( "Saved OldMon config to: %s\n", m_configFile.string().c_str() );
}

void OldMon::show()
{
  ImGui::Begin( "Capture Select" );
  showVersionComboBox();
  showCaptureList();

  // Add database configuration button
  ImGui::Separator();
  if( ImGui::Button( "Database Config", ImVec2( -1, 0 ) ) )
  {
    m_showDbConfigDialog = true;
  }

  // Show connection status
  if( m_dbConnectionOpen )
  {
    ImGui::TextColored( ImVec4( 0.2f, 0.8f, 0.2f, 1.0f ), "✓ Connected to %s@%s:%d/%s",
                        m_dbConnectionInfo.user.c_str(),
                        m_dbConnectionInfo.host.c_str(),
                        m_dbConnectionInfo.port,
                        m_dbConnectionInfo.database.c_str() );
  }
  else
  {
    ImGui::TextColored( ImVec4( 0.8f, 0.2f, 0.2f, 1.0f ), "✗ Database not connected" );
  }

  ImGui::End();

  // Show packet viewer window
  //if (m_showPacketViewer)
  {
    showPacketViewer();
  }

  // Show database config dialog
  if( m_showDbConfigDialog )
  {
    showDbConfigDialog();
  }
}

void OldMon::initDbConfigBuffers()
{
  strncpy( m_dbUserBuffer, m_dbConnectionInfo.user.c_str(), sizeof( m_dbUserBuffer ) - 1 );
  m_dbUserBuffer[ sizeof( m_dbUserBuffer ) - 1 ] = '\0';

  strncpy( m_dbPasswordBuffer, m_dbConnectionInfo.password.c_str(), sizeof( m_dbPasswordBuffer ) - 1 );
  m_dbPasswordBuffer[ sizeof( m_dbPasswordBuffer ) - 1 ] = '\0';

  strncpy( m_dbDatabaseBuffer, m_dbConnectionInfo.database.c_str(), sizeof( m_dbDatabaseBuffer ) - 1 );
  m_dbDatabaseBuffer[ sizeof( m_dbDatabaseBuffer ) - 1 ] = '\0';

  strncpy( m_dbHostBuffer, m_dbConnectionInfo.host.c_str(), sizeof( m_dbHostBuffer ) - 1 );
  m_dbHostBuffer[ sizeof( m_dbHostBuffer ) - 1 ] = '\0';

  m_dbPortBuffer = m_dbConnectionInfo.port;
}

bool OldMon::connectToDatabase()
{
  try
  {
    m_dbConnection = std::make_shared< Sapphire::Db::DbConnection >( m_dbConnectionInfo );
    uint32_t result = m_dbConnection->open();

    if( result == 0 )
    {
      m_dbConnectionOpen = true;
      return true;
    }
    else
    {
      m_dbConnectionOpen = false;
      m_dbConnection.reset();
      return false;
    }
  } catch( const std::exception& e )
  {
    printf( "Database connection failed: %s\n", e.what() );
    m_dbConnectionOpen = false;
    m_dbConnection.reset();
    return false;
  }
}

void OldMon::showDbConfigDialog()
{
  ImGui::SetNextWindowSize( ImVec2( 450, 300 ), ImGuiCond_FirstUseEver );

  if( !ImGui::Begin( "Database Configuration", &m_showDbConfigDialog, ImGuiWindowFlags_NoCollapse ) )
  {
    ImGui::End();
    return;
  }

  ImGui::Text( "Configure database connection settings:" );
  ImGui::Separator();

  // Create a table layout for better alignment
  if( ImGui::BeginTable( "DbConfigTable", 2, ImGuiTableFlags_SizingFixedFit ) )
  {
    ImGui::TableSetupColumn( "Label", ImGuiTableColumnFlags_WidthFixed, 80.0f );
    ImGui::TableSetupColumn( "Input", ImGuiTableColumnFlags_WidthStretch );

    // Host
    ImGui::TableNextRow();
    ImGui::TableNextColumn();
    ImGui::AlignTextToFramePadding();
    ImGui::Text( "Host:" );
    ImGui::TableNextColumn();
    ImGui::SetNextItemWidth( -1.0f );
    ImGui::InputText( "##Host", m_dbHostBuffer, sizeof( m_dbHostBuffer ) );

    // Port
    ImGui::TableNextRow();
    ImGui::TableNextColumn();
    ImGui::AlignTextToFramePadding();
    ImGui::Text( "Port:" );
    ImGui::TableNextColumn();
    ImGui::SetNextItemWidth( -1.0f );
    ImGui::InputInt( "##Port", &m_dbPortBuffer );
    // Clamp port to valid range
    if( m_dbPortBuffer < 1 ) m_dbPortBuffer = 1;
    if( m_dbPortBuffer > 65535 ) m_dbPortBuffer = 65535;

    // Username
    ImGui::TableNextRow();
    ImGui::TableNextColumn();
    ImGui::AlignTextToFramePadding();
    ImGui::Text( "Username:" );
    ImGui::TableNextColumn();
    ImGui::SetNextItemWidth( -1.0f );
    ImGui::InputText( "##Username", m_dbUserBuffer, sizeof( m_dbUserBuffer ) );

    // Password
    ImGui::TableNextRow();
    ImGui::TableNextColumn();
    ImGui::AlignTextToFramePadding();
    ImGui::Text( "Password:" );
    ImGui::TableNextColumn();
    ImGui::SetNextItemWidth( -1.0f );
    ImGui::InputText( "##Password", m_dbPasswordBuffer, sizeof( m_dbPasswordBuffer ), ImGuiInputTextFlags_Password );

    // Database
    ImGui::TableNextRow();
    ImGui::TableNextColumn();
    ImGui::AlignTextToFramePadding();
    ImGui::Text( "Database:" );
    ImGui::TableNextColumn();
    ImGui::SetNextItemWidth( -1.0f );
    ImGui::InputText( "##Database", m_dbDatabaseBuffer, sizeof( m_dbDatabaseBuffer ) );

    ImGui::EndTable();
  }

  ImGui::Separator();

  // Current connection status
  if( m_dbConnectionOpen )
  {
    ImGui::TextColored( ImVec4( 0.2f, 0.8f, 0.2f, 1.0f ), "✓ Currently connected" );
  }
  else
  {
    ImGui::TextColored( ImVec4( 0.8f, 0.2f, 0.2f, 1.0f ), "✗ Not connected" );
  }

  ImGui::Spacing();

  // Buttons
  if( ImGui::Button( "Test Connection", ImVec2( 120, 0 ) ) )
  {
    // Apply current buffer values to connection info temporarily for testing
    Sapphire::Db::ConnectionInfo testInfo = m_dbConnectionInfo;
    testInfo.host = std::string( m_dbHostBuffer );
    testInfo.port = m_dbPortBuffer;
    testInfo.user = std::string( m_dbUserBuffer );
    testInfo.password = std::string( m_dbPasswordBuffer );
    testInfo.database = std::string( m_dbDatabaseBuffer );

    try
    {
      auto testConnection = std::make_shared< Sapphire::Db::DbConnection >( testInfo );
      uint32_t result = testConnection->open();

      if( result == 0 )
      {
        testConnection->close();
        ImGui::OpenPopup( "Connection Success" );
      }
      else
      {
        ImGui::OpenPopup( "Connection Failed" );
      }
    } catch( const std::exception& e )
    {
      printf( "Test connection failed: %s\n", e.what() );
      ImGui::OpenPopup( "Connection Failed" );
    }
  }

  ImGui::SameLine();

  if( ImGui::Button( "Apply & Save", ImVec2( 120, 0 ) ) )
  {
    // Apply buffer values to connection info
    m_dbConnectionInfo.host = std::string( m_dbHostBuffer );
    m_dbConnectionInfo.port = m_dbPortBuffer;
    m_dbConnectionInfo.user = std::string( m_dbUserBuffer );
    m_dbConnectionInfo.password = std::string( m_dbPasswordBuffer );
    m_dbConnectionInfo.database = std::string( m_dbDatabaseBuffer );

    // Save config to file
    saveConfig();

    // Close existing connection
    if( m_dbConnection )
    {
      m_dbConnection->close();
      m_dbConnection.reset();
      m_dbConnectionOpen = false;
    }

    // Connect with new settings
    if( connectToDatabase() )
    {
      loadVersions(); // Reload versions with new connection
      ImGui::OpenPopup( "Settings Saved" );
    }
    else
    {
      ImGui::OpenPopup( "Connection Failed" );
    }

    m_showDbConfigDialog = false;
  }

  ImGui::SameLine();

  if( ImGui::Button( "Cancel", ImVec2( 120, 0 ) ) )
  {
    // Restore original values
    initDbConfigBuffers();
    m_showDbConfigDialog = false;
  }

  // Success popup
  if( ImGui::BeginPopupModal( "Connection Success", nullptr, ImGuiWindowFlags_AlwaysAutoResize ) )
  {
    ImGui::TextColored( ImVec4( 0.2f, 0.8f, 0.2f, 1.0f ), "✓ Connection test successful!" );
    ImGui::Text( "Settings are valid but not yet saved." );
    ImGui::Text( "Click 'Apply & Save' to make them permanent." );
    ImGui::Spacing();
    if( ImGui::Button( "OK" ) )
    {
      ImGui::CloseCurrentPopup();
    }
    ImGui::EndPopup();
  }

  // Settings saved popup
  if( ImGui::BeginPopupModal( "Settings Saved", nullptr, ImGuiWindowFlags_AlwaysAutoResize ) )
  {
    ImGui::TextColored( ImVec4( 0.2f, 0.8f, 0.2f, 1.0f ), "✓ Settings saved and applied!" );
    ImGui::Text( "Connected to: %s@%s:%d/%s",
                 m_dbConnectionInfo.user.c_str(),
                 m_dbConnectionInfo.host.c_str(),
                 m_dbConnectionInfo.port,
                 m_dbConnectionInfo.database.c_str() );
    ImGui::Spacing();
    if( ImGui::Button( "OK" ) )
    {
      ImGui::CloseCurrentPopup();
    }
    ImGui::EndPopup();
  }

  // Failure popup
  if( ImGui::BeginPopupModal( "Connection Failed", nullptr, ImGuiWindowFlags_AlwaysAutoResize ) )
  {
    ImGui::TextColored( ImVec4( 0.8f, 0.2f, 0.2f, 1.0f ), "✗ Connection failed!" );
    ImGui::TextWrapped( "Please check your connection settings and ensure the database server is running." );
    ImGui::Spacing();
    if( ImGui::Button( "OK" ) )
    {
      ImGui::CloseCurrentPopup();
    }
    ImGui::EndPopup();
  }

  ImGui::End();
}

void OldMon::loadVersions()
{
  if( !m_dbConnectionOpen || !m_dbConnection )
  {
    printf( "Database not connected, cannot load versions\n" );
    return;
  }

  try
  {
    auto res = m_dbConnection->query( "SELECT * FROM versions" );

    if( !res )
    {
      printf( "Failed to query versions table\n" );
      return;
    }

    m_versions.clear();
    while( res->next() )
    {
      uint32_t id = static_cast< uint32_t >( res->getUInt64( 1 ) );
      std::string name = res->getString( 2 );

      Version v{ id, name };
      m_versions.push_back( v );
    }
  } catch( const std::exception& e )
  {
    printf( "Error loading versions: %s\n", e.what() );
  }
}

void OldMon::loadCaptures( uint32_t versionId )
{
  std::string query = fmt::format( "SELECT * FROM captures WHERE version_id = {};", versionId );
  auto res = m_dbConnection->query( query );

  while( res->next() )
  {
    uint32_t id = static_cast< uint32_t >( res->getUInt64( 1 ) );
    uint32_t versionId = static_cast< uint32_t >( res->getUInt64( 2 ) );
    std::string name = res->getString( 3 );
    std::string desc = res->getString( 4 );

    Capture c{ id, versionId, name, desc };
    m_captures.push_back( c );
  }
}

void OldMon::loadCapture( uint32_t captureId )
{
  auto capture = getSelectedCapture();
  if( capture && capture->packetSets.size() > 0 )
    return;

  std::string query = fmt::format( "SELECT * FROM packet_set WHERE capture_id = {} ORDER BY id ASC;", captureId );
  auto res = m_dbConnection->query( query );

  while( res->next() )
  {
    PacketSet set;
    set.id = static_cast< uint32_t >( res->getUInt64( 1 ) );
    set.captureId = static_cast< uint32_t >( res->getUInt64( 2 ) );
    set.direction = static_cast< uint32_t >( res->getUInt64( 3 ) );
    memcpy( set.headerData, res->getBlobVector( 4 ).data(), 40 );
    set.portSrc = static_cast< uint16_t >( res->getUInt64( 5 ) );
    set.portDst = static_cast< uint16_t >( res->getUInt64( 6 ) );

    capture->packetSets.push_back( set );
  }

  for( auto& set : capture->packetSets )
  {
    std::string query = fmt::format( "SELECT * FROM packet WHERE packet_set_id = {} ORDER BY id ASC;", set.id );
    auto res = m_dbConnection->query( query );
    Packet pack;
    while( res->next() )
    {
      pack.id = static_cast< uint32_t >( res->getUInt64( 1 ) );
      pack.captureId = static_cast< uint32_t >( res->getUInt64( 2 ) );
      auto packetData = res->getBlobVector( 3 );
      pack.data.resize( packetData.size() );
      memcpy( pack.data.data(), packetData.data(), packetData.size() );
      pack.comment = res->getString( 4 );
      pack.packetSetId = res->getUInt64( 5 );
      pack.packetType = static_cast< uint32_t >( res->getUInt64( 6 ) );
      pack.packetAdditional = static_cast< uint32_t >( res->getUInt64( 7 ) );
      pack.isForSelf = static_cast< uint32_t >( res->getUInt64( 8 ) );
      pack.packetSize = static_cast< uint32_t >( res->getUInt64( 9 ) );
      pack.packetTimeStamp = static_cast< uint32_t >( res->getUInt64( 10 ) );
      pack.packetCategory = static_cast< uint32_t >( res->getUInt64( 11 ) );
      set.packets.push_back( pack );
    }
  }
}

void OldMon::refresh()
{
}

void OldMon::showVersionComboBox()
{
  // Version selection combobox
  if( ImGui::BeginCombo( "Version", m_versions.empty()
                                      ? "No versions available"
                                      : m_versions[ m_selectedVersionIdx ].name.c_str() ) )
  {
    for( uint32_t i = 0; i < m_versions.size(); ++i )
    {
      const bool isSelected = ( m_selectedVersionIdx == i );

      // Create display string with version number and name
      std::string displayText = std::to_string( m_versions[ i ].version ) + " - " + m_versions[ i ].name;

      if( ImGui::Selectable( displayText.c_str(), isSelected ) )
      {
        if( m_selectedVersionIdx != i )
        {
          m_selectedVersionIdx = i;
          // Add any callback or refresh logic here when version changes
          onVersionChanged();
        }
      }

      // Set the initial focus when opening the combo (scrolls to the selected item)
      if( isSelected )
        ImGui::SetItemDefaultFocus();
    }
    ImGui::EndCombo();
  }
}

void OldMon::showCaptureList()
{
  ImGui::Separator();

  // Capture selection list
  ImGui::Text( "Captures:" );

  // Create a child window for the capture list with scrolling
  if( ImGui::BeginChild( "CaptureList", ImVec2( 0, 600 ), true, ImGuiWindowFlags_HorizontalScrollbar ) )
  {
    if( m_captures.empty() )
    {
      ImGui::TextDisabled( "No captures available" );
    }
    else
    {
      // Filter captures by selected version if needed
      std::vector< uint32_t > filteredIndices;
      for( uint32_t i = 0; i < m_captures.size(); ++i )
      {
        // Show all captures or filter by version
        if( m_versions.empty() || m_captures[ i ].versionId == m_versions[ m_selectedVersionIdx ].version )
        {
          filteredIndices.push_back( i );
        }
      }

      if( filteredIndices.empty() )
      {
        ImGui::TextDisabled( "No captures for selected version" );
      }
      else
      {
        for( uint32_t filteredIdx : filteredIndices )
        {
          const auto& capture = m_captures[ filteredIdx ];
          const bool isSelected = ( m_selectedCaptureIdx == filteredIdx );

          // Create display string with ID and name
          std::string displayText = std::to_string( capture.id ) + " - " + capture.name;

          if( ImGui::Selectable( displayText.c_str(), isSelected ) )
          {
            if( m_selectedCaptureIdx != filteredIdx )
            {
              m_selectedCaptureIdx = filteredIdx;
              m_selectedCaptureId = capture.id;
              onCaptureChanged();
            }
          }

          // Show tooltip with description if available
          if( ImGui::IsItemHovered() && !capture.description.empty() )
          {
            ImGui::BeginTooltip();
            ImGui::Text( "ID: %u", capture.id );
            ImGui::Text( "Version ID: %u", capture.versionId );
            ImGui::Text( "Description: %s", capture.description.c_str() );
            ImGui::EndTooltip();
          }
        }
      }
    }
  }
  ImGui::EndChild();

  // Show selected capture details
  if( const Capture *selectedCapture = getSelectedCapture() )
  {
    ImGui::Separator();
    ImGui::Text( "Selected Capture Details:" );
    ImGui::Indent();
    ImGui::Text( "ID: %u", selectedCapture->id );
    ImGui::Text( "Version ID: %u", selectedCapture->versionId );
    ImGui::Text( "Name: %s", selectedCapture->name.c_str() );
    // Count total packets
    size_t totalPackets = 0;
    for( const auto& packetSet : selectedCapture->packetSets )
    {
      totalPackets += packetSet.packets.size();
    }
    ImGui::Text( "Total Packets: %zu", totalPackets );

    if( !selectedCapture->description.empty() )
    {
      ImGui::Text( "Description: %s", selectedCapture->description.c_str() );
    }
    ImGui::Unindent();
  }
}

uint32_t OldMon::getSelectedCaptureId() const
{
  return m_selectedCaptureId;
}


void OldMon::onVersionChanged()
{
  // Add any logic you need when the version selection changes
  // For example, refresh data, update displays, etc.
  loadCaptures( m_versions[ m_selectedVersionIdx ].version );
  refresh();
}

void OldMon::onCaptureChanged()
{
  m_selectedPacketIdx = 0;
  m_flatPacketList.clear();


  loadCapture( m_selectedCaptureId );
  buildFlatPacketList();
}

void OldMon::buildFlatPacketList()
{
  m_flatPacketList.clear();

  const Capture *selectedCapture = getSelectedCapture();
  if( !selectedCapture )
    return;

  // Flatten all packets from all packet sets into a single list
  for( const auto& packetSet : selectedCapture->packetSets )
  {
    for( const auto& packet : packetSet.packets )
    {
      m_flatPacketList.push_back( &packet );
    }
  }

  // Sort by timestamp for chronological order
  std::sort( m_flatPacketList.begin(), m_flatPacketList.end(),
             []( const Packet *a, const Packet *b )
             {
               return a->id < b->id;
             } );
}

void OldMon::showPacketViewer()
{
  if( !ImGui::Begin( "Packet Viewer", &m_showPacketViewer, ImGuiWindowFlags_MenuBar ) )
  {
    ImGui::End();
    return;
  }

  // Menu bar
  if( ImGui::BeginMenuBar() )
  {
    const Capture *selectedCapture = getSelectedCapture();
    if( selectedCapture )
    {
      ImGui::Text( "Capture: %s | Packets: %zu", selectedCapture->name.c_str(), m_flatPacketList.size() );
    }

    ImGui::Separator();
    ImGui::Checkbox( "Data Inspector", &m_showDataInspector );

    ImGui::EndMenuBar();
  }

  // Split the window horizontally
  ImVec2 contentRegion = ImGui::GetContentRegionAvail();

  // Top half - packet grid
  if( ImGui::BeginChild( "PacketGrid", ImVec2( 0, contentRegion.y * 0.6f ), true ) )
  {
    showPacketGrid();
  }
  ImGui::EndChild();

  ImGui::Separator();

  // Bottom half - split between hex viewer and data inspector
  if( ImGui::BeginChild( "DataViewer", ImVec2( 0, 0 ), true ) )
  {
    if( m_selectedPacketIdx < m_flatPacketList.size() )
    {
      const Packet *currentPacket = m_flatPacketList[ m_selectedPacketIdx ];

      if( m_showDataInspector )
      {
        // Split horizontally: hex viewer on left, data inspector on right
        ImVec2 dataViewerRegion = ImGui::GetContentRegionAvail();

        if( ImGui::BeginChild( "HexViewerPane", ImVec2( dataViewerRegion.x * 0.7f, 0 ), true ) )
        {
          showHexViewer( currentPacket );
        }
        ImGui::EndChild();

        ImGui::SameLine();

        if( ImGui::BeginChild( "DataInspectorPane", ImVec2( 0, 0 ), true ) )
        {
          showDataInspector( currentPacket );
        }
        ImGui::EndChild();
      }
      else
      {
        showHexViewer( currentPacket );
      }
    }
    else
    {
      ImGui::TextDisabled( "No packet selected" );
    }
  }
  ImGui::EndChild();

  ImGui::End();
}

void OldMon::showHexViewer( const Packet *packet )
{
  if( !packet )
    return;

  ImGui::Text( "Packet ID: %u | Type: 0x%04X | Size: %u bytes",
               packet->id, packet->packetType, packet->packetSize );

  if( m_selectedByteOffset != SIZE_MAX && m_selectedByteOffset < packet->data.size() )
  {
    ImGui::SameLine();
    ImGui::Text( " | Selected: 0x%08zX (%zu)", m_selectedByteOffset, m_selectedByteOffset );
  }

  ImGui::Separator();

  if( packet->data.empty() )
  {
    ImGui::TextDisabled( "No data to display" );
    return;
  }

  // Hex viewer
  ImGui::BeginChild( "HexData", ImVec2( 0, 0 ), false, ImGuiWindowFlags_HorizontalScrollbar );

  const uint8_t *data = packet->data.data();
  size_t dataSize = packet->data.size();

  const int bytesPerLine = 16;
  const float charWidth = ImGui::CalcTextSize( "0" ).x;
  const float hexByteWidth = charWidth * 2.5f; // Increased button width for better visibility

  // Define colors for the first 0x20 bytes (8 groups of 4 bytes each)
  ImVec4 headerColors[ 8 ] = {
    ImVec4( 1.0f, 0.8f, 0.8f, 1.0f ), // Light red
    ImVec4( 0.8f, 1.0f, 0.8f, 1.0f ), // Light green
    ImVec4( 0.8f, 0.8f, 1.0f, 1.0f ), // Light blue
    ImVec4( 1.0f, 1.0f, 0.8f, 1.0f ), // Light yellow
    ImVec4( 1.0f, 0.8f, 1.0f, 1.0f ), // Light magenta
    ImVec4( 0.8f, 1.0f, 1.0f, 1.0f ), // Light cyan
    ImVec4( 1.0f, 0.9f, 0.8f, 1.0f ), // Light orange
    ImVec4( 0.9f, 0.9f, 0.9f, 1.0f ) // Light gray
  };

  for( size_t offset = 0; offset < dataSize; offset += bytesPerLine )
  {
    ImVec2 lineStartPos = ImGui::GetCursorScreenPos();

    // Offset column
    ImGui::Text( "%08zX", offset );
    ImGui::SameLine();
    ImGui::SetCursorPosX( ImGui::GetCursorPosX() + 10 );

    // Hex columns - handle each byte individually for coloring and clicking
    ImVec2 hexStartPos = ImGui::GetCursorScreenPos();
    std::string asciiLine;

    for( int i = 0; i < bytesPerLine; ++i )
    {
      if( offset + i < dataSize )
      {
        uint8_t byte = data[ offset + i ];
        size_t absoluteOffset = offset + i;

        // Determine color based on position within first 0x20 bytes
        ImVec4 textColor = ImVec4( 1.0f, 1.0f, 1.0f, 1.0f ); // Default white
        if( absoluteOffset < 0x20 )
        {
          int groupIndex = ( int ) ( absoluteOffset / 4 ); // Groups of 4 bytes
          textColor = headerColors[ groupIndex ];
        }

        // Highlight selected byte
        bool isSelected = ( absoluteOffset == m_selectedByteOffset );
        if( isSelected )
        {
          ImGui::PushStyleColor( ImGuiCol_Text, ImVec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); // Black text
          ImGui::PushStyleColor( ImGuiCol_Button, ImVec4( 1.0f, 1.0f, 0.0f, 1.0f ) ); // Yellow background
        }
        else
        {
          ImGui::PushStyleColor( ImGuiCol_Text, textColor );
          ImGui::PushStyleColor( ImGuiCol_Button, ImVec4( 0.0f, 0.0f, 0.0f, 0.0f ) ); // Transparent
        }

        // Make hex byte clickable
        ImGui::PushID( static_cast< int >( absoluteOffset ) );
        if( ImGui::Button( fmt::format( "{:02X}", byte ).c_str(), ImVec2( hexByteWidth, 0 ) ) )
        {
          m_selectedByteOffset = absoluteOffset;
        }
        ImGui::PopID();

        ImGui::PopStyleColor( 2 );

        // Position for next hex byte - reduced spacing
        if( i < bytesPerLine - 1 )
        {
          ImGui::SameLine();
          ImGui::SetCursorPosX( ImGui::GetCursorPosX() + 2 ); // Reduced from charWidth to 2 pixels
        }

        // ASCII representation
        char asciiChar = ( byte >= 32 && byte <= 126 ) ? static_cast< char >( byte ) : '.';
        asciiLine += asciiChar;
      }
      else
      {
        // Empty space for missing bytes
        ImGui::Button( "  ", ImVec2( hexByteWidth, 0 ) );
        if( i < bytesPerLine - 1 )
        {
          ImGui::SameLine();
          ImGui::SetCursorPosX( ImGui::GetCursorPosX() + 2 );
        }
        asciiLine += " ";
      }
    }

    // ASCII column
    ImGui::SameLine();
    ImGui::SetCursorPosX( ImGui::GetCursorPosX() + 15 ); // Reduced spacing

    // Color the ASCII representation as well for the first 0x20 bytes
    ImGui::Text( "| " );
    ImGui::SameLine();

    for( size_t i = 0; i < asciiLine.length() && ( offset + i ) < dataSize; ++i )
    {
      size_t absoluteOffset = offset + i;

      // Determine color based on position within first 0x20 bytes
      ImVec4 textColor = ImVec4( 1.0f, 1.0f, 1.0f, 1.0f ); // Default white
      if( absoluteOffset < 0x20 )
      {
        int groupIndex = ( int ) ( absoluteOffset / 4 ); // Groups of 4 bytes
        textColor = headerColors[ groupIndex ];
      }

      bool isSelected = ( absoluteOffset == m_selectedByteOffset );
      if( isSelected )
      {
        ImGui::PushStyleColor( ImGuiCol_Text, ImVec4( 0.0f, 0.0f, 0.0f, 1.0f ) ); // Black text
        ImGui::PushStyleColor( ImGuiCol_Button, ImVec4( 1.0f, 1.0f, 0.0f, 1.0f ) ); // Yellow background
      }
      else
      {
        ImGui::PushStyleColor( ImGuiCol_Text, textColor );
        ImGui::PushStyleColor( ImGuiCol_Button, ImVec4( 0.0f, 0.0f, 0.0f, 0.0f ) ); // Transparent
      }

      ImGui::PushID( static_cast< int >( absoluteOffset + 10000 ) ); // Different ID range for ASCII
      if( ImGui::Button( fmt::format( "{}", asciiLine[ i ] ).c_str(), ImVec2( charWidth * 1.2f, 0 ) ) )
      {
        m_selectedByteOffset = absoluteOffset;
      }
      ImGui::PopID();

      ImGui::PopStyleColor( 2 );

      if( i < asciiLine.length() - 1 )
      {
        ImGui::SameLine();
      }
    }
  }

  ImGui::EndChild();
}

void OldMon::showDataInspector( const Packet *packet )
{
  ImGui::Text( "Data Inspector" );
  ImGui::Separator();

  if( !packet || packet->data.empty() )
  {
    ImGui::TextDisabled( "No data to inspect" );
    return;
  }

  if( m_selectedByteOffset == SIZE_MAX || m_selectedByteOffset >= packet->data.size() )
  {
    ImGui::TextDisabled( "Click on a byte in the hex viewer to inspect data" );
    return;
  }

  const uint8_t *data = packet->data.data();
  size_t dataSize = packet->data.size();
  size_t offset = m_selectedByteOffset;

  ImGui::Text( "Offset: 0x%08zX (%zu)", offset, offset );
  ImGui::Separator();

  // 8-bit values
  if( ImGui::CollapsingHeader( "8-bit Values", ImGuiTreeNodeFlags_DefaultOpen ) )
  {
    if( offset < dataSize )
    {
      uint8_t u8_val = data[ offset ];
      int8_t i8_val = static_cast< int8_t >( u8_val );

      ImGui::Text( "uint8:  %u (0x%02X)", u8_val, u8_val );
      ImGui::Text( "int8:   %d", i8_val );
      ImGui::Text( "char:   '%c' (%s)",
                   ( u8_val >= 32 && u8_val <= 126 ) ? static_cast< char >( u8_val ) : '.',
                   ( u8_val >= 32 && u8_val <= 126 ) ? "printable" : "non-printable" );
    }
    else
    {
      ImGui::TextDisabled( "Not enough data" );
    }
  }

  // 16-bit values
  if( ImGui::CollapsingHeader( "16-bit Values", ImGuiTreeNodeFlags_DefaultOpen ) )
  {
    if( offset + 1 < dataSize )
    {
      // Little endian
      uint16_t u16_le = *reinterpret_cast< const uint16_t * >( &data[ offset ] );
      int16_t i16_le = static_cast< int16_t >( u16_le );

      ImGui::Text( "uint16: %u (0x%04X)", u16_le, u16_le );
      ImGui::Text( "int16:  %d", i16_le );
    }
    else
    {
      ImGui::TextDisabled( "Not enough data" );
    }
  }

  // 32-bit values
  if( ImGui::CollapsingHeader( "32-bit Values", ImGuiTreeNodeFlags_DefaultOpen ) )
  {
    if( offset + 3 < dataSize )
    {
      // Little endian
      uint32_t u32_le = *reinterpret_cast< const uint32_t * >( &data[ offset ] );
      int32_t i32_le = static_cast< int32_t >( u32_le );
      float f32_le = *reinterpret_cast< const float * >( &data[ offset ] );

      // Big endian
      uint32_t u32_be = ( static_cast< uint32_t >( data[ offset ] ) << 24 ) |
                        ( static_cast< uint32_t >( data[ offset + 1 ] ) << 16 ) |
                        ( static_cast< uint32_t >( data[ offset + 2 ] ) << 8 ) |
                        data[ offset + 3 ];
      int32_t i32_be = static_cast< int32_t >( u32_be );
      float f32_be;
      memcpy( &f32_be, &u32_be, sizeof( float ) );

      ImGui::Text( "uint32: %u (0x%08X)", u32_le, u32_le );
      ImGui::Text( "int32:  %d", i32_le );
      ImGui::Text( "float:  %.6f", f32_le );
    }
    else
    {
      ImGui::TextDisabled( "Not enough data" );
    }
  }

  // 64-bit values
  if( ImGui::CollapsingHeader( "64-bit Values" ) )
  {
    if( offset + 7 < dataSize )
    {
      // Little endian
      uint64_t u64_le = *reinterpret_cast< const uint64_t * >( &data[ offset ] );
      int64_t i64_le = static_cast< int64_t >( u64_le );
      double d64_le = *reinterpret_cast< const double * >( &data[ offset ] );

      ImGui::Text( "uint64: %llu (0x%016llX)", u64_le, u64_le );
      ImGui::Text( "int64:  %lld", i64_le );
      ImGui::Text( "double: %.10f", d64_le );

      // Time interpretation (Unix timestamp) - use first 4 bytes as uint32
      uint32_t timestamp_val = *reinterpret_cast< const uint32_t * >( &data[ offset ] );
      if( timestamp_val > 0 && timestamp_val < 0xFFFFFFFF )
      {
        time_t timestamp = static_cast< time_t >( timestamp_val );
        struct tm *timeinfo = localtime( &timestamp );
        if( timeinfo )
        {
          char time_str[ 100 ];
          strftime( time_str, sizeof( time_str ), "%Y-%m-%d %H:%M:%S", timeinfo );
          ImGui::Text( "Unix time: %s", time_str );
        }
      }
    }
    else
    {
      ImGui::TextDisabled( "Not enough data" );
    }
  }

  // String interpretations
  if( ImGui::CollapsingHeader( "String Values" ) )
  {
    // Null-terminated string
    std::string nullTermStr;
    for( size_t i = offset; i < dataSize && i < offset + 32; ++i )
    {
      if( data[ i ] == 0 ) break;
      if( data[ i ] >= 32 && data[ i ] <= 126 )
      {
        nullTermStr += static_cast< char >( data[ i ] );
      }
      else
      {
        nullTermStr += '.';
      }
    }

    // Fixed-length string
    std::string fixedStr;
    for( size_t i = offset; i < dataSize && i < offset + 16; ++i )
    {
      if( data[ i ] >= 32 && data[ i ] <= 126 )
      {
        fixedStr += static_cast< char >( data[ i ] );
      }
      else
      {
        fixedStr += '.';
      }
    }

    ImGui::Text( "Null-term: \"%s\"", nullTermStr.c_str() );
    ImGui::Text( "Fixed 16:  \"%s\"", fixedStr.c_str() );
  }

  // Raw bytes view
  if( ImGui::CollapsingHeader( "Raw Bytes" ) )
  {
    ImGui::Text( "Next 16 bytes from offset:" );
    std::string hexStr, asciiStr;
    for( size_t i = 0; i < 16 && ( offset + i ) < dataSize; ++i )
    {
      hexStr += fmt::format( "{:02X} ", data[ offset + i ] );
      char c = ( data[ offset + i ] >= 32 && data[ offset + i ] <= 126 )
                 ? static_cast< char >( data[ offset + i ] )
                 : '.';
      asciiStr += c;
    }
    ImGui::Text( "Hex:   %s", hexStr.c_str() );
    ImGui::Text( "ASCII: %s", asciiStr.c_str() );
  }
}

#include <fstream>

void OldMon::showPacketGrid()
{
  if( m_flatPacketList.empty() )
  {
    ImGui::TextDisabled( "No packets to display" );
    return;
  }

  const Capture *selectedCapture = getSelectedCapture();
  if( !selectedCapture )
    return;

  // Filters at the top
  static char filterTypeInput[ 16 ] = ""; // Hexadecimal filter input
  static char filterSrcIdInput[ 16 ] = ""; // Hexadecimal filter input for SrcId

  ImGui::Text( "Filters" );

  // Type filter
  ImGui::Text( "Type:" );
  ImGui::SameLine();
  ImGui::InputTextWithHint( "##TypeFilter", "Enter Type (Hex)", filterTypeInput, sizeof( filterTypeInput ),
                            ImGuiInputTextFlags_CharsHexadecimal );

  ImGui::SameLine();

  // SrcId filter
  ImGui::Text( "SrcId:" );
  ImGui::SameLine();
  ImGui::InputTextWithHint( "##SrcIdFilter", "Enter SrcId (Hex)", filterSrcIdInput, sizeof( filterSrcIdInput ),
                            ImGuiInputTextFlags_CharsHexadecimal );

  // Clear filter button
  ImGui::SameLine();
  if( ImGui::Button( "Clear Filters" ) )
  {
    filterTypeInput[ 0 ] = '\0';
    filterSrcIdInput[ 0 ] = '\0';
  }

  // Debug info
  ImGui::SameLine();
  ImGui::Text( "Active filters - Type: '%s', SrcId: '%s'", filterTypeInput, filterSrcIdInput );

  // Horizontal separator
  ImGui::Separator();

  // Helper function to check if hex string starts with filter
  auto hexStringStartsWith = []( uint32_t value, const char *filter ) -> bool
  {
    if( strlen( filter ) == 0 )
      return true; // Empty filter matches everything

    char valueStr[ 16 ];
    sprintf( valueStr, "%X", value );

    // Convert both to uppercase for case-insensitive comparison
    std::string valueUpper = valueStr;
    std::string filterUpper = filter;
    std::transform( valueUpper.begin(), valueUpper.end(), valueUpper.begin(), ::toupper );
    std::transform( filterUpper.begin(), filterUpper.end(), filterUpper.begin(), ::toupper );

    return valueUpper.find( filterUpper ) == 0; // Check if it starts with filter
  };

  // Create a map of packet set IDs to packet sets for quick lookup
  std::unordered_map< uint32_t, const PacketSet * > packetSetMap;
  for( const auto& packetSet : selectedCapture->packetSets )
  {
    packetSetMap[ packetSet.id ] = &packetSet;
  }

  if( ImGui::BeginTable( "PacketsTable", 7,
                         ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg |
                         ImGuiTableFlags_ScrollY | ImGuiTableFlags_Resizable |
                         ImGuiTableFlags_Sortable ) )
  {
    // Set up columns
    ImGui::TableSetupColumn( "Dir", ImGuiTableColumnFlags_WidthFixed, 40.0f );
    ImGui::TableSetupColumn( "Type", ImGuiTableColumnFlags_WidthFixed, 80.0f );
    ImGui::TableSetupColumn( "SrcId", ImGuiTableColumnFlags_WidthFixed, 80.0f );
    ImGui::TableSetupColumn( "Size", ImGuiTableColumnFlags_WidthFixed, 60.0f );
    ImGui::TableSetupColumn( "Timestamp", ImGuiTableColumnFlags_WidthFixed, 100.0f );
    ImGui::TableSetupColumn( "Self", ImGuiTableColumnFlags_WidthFixed, 40.0f );
    ImGui::TableSetupColumn( "Comment", ImGuiTableColumnFlags_WidthStretch );
    ImGui::TableHeadersRow();

    uint8_t prevDirection = 255; // Invalid initial value
    uint32_t prevPacketSetId = 0;
    size_t consecutiveCount = 0;

    // Count visible packets for debug
    int visiblePackets = 0;
    int totalPackets = m_flatPacketList.size();

    // Display filtered packets
    for( size_t i = 0; i < m_flatPacketList.size(); ++i )
    {
      const Packet *packet = m_flatPacketList[ i ];

      // Apply type filter if one is set
      if( strlen( filterTypeInput ) > 0 && !hexStringStartsWith( packet->packetType, filterTypeInput ) )
        continue;

      // Extract SrcId with better error handling
      uint32_t srcId = 0;
      if( packet->data.size() >= 8 )
      {
        // Try different offsets as the structure might vary
        srcId = *reinterpret_cast< const uint32_t * >( &packet->data[ 4 ] );
      }
      else if( packet->data.size() >= 4 )
      {
        // Fallback to offset 0 if packet is smaller
        srcId = *reinterpret_cast< const uint32_t * >( &packet->data[ 0 ] );
      }

      // Apply SrcId filter if one is set
      if( strlen( filterSrcIdInput ) > 0 && !hexStringStartsWith( srcId, filterSrcIdInput ) )
        continue;

      visiblePackets++;

      const bool isSelected = ( m_selectedPacketIdx == i );

      // Get packet set for this packet
      auto packetSetIt = packetSetMap.find( packet->packetSetId );
      const PacketSet *packetSet = ( packetSetIt != packetSetMap.end() ) ? packetSetIt->second : nullptr;

      if( packetSet )
      {
        if( packetSet->direction == prevDirection && packet->packetSetId != prevPacketSetId )
        {
          consecutiveCount++;
        }
        else
        {
          consecutiveCount = 0;
        }
        prevDirection = packetSet->direction;
        prevPacketSetId = packet->packetSetId;
      }

      ImGui::TableNextRow();

      // Apply packet set color with direction-specific tints and alternation
      ImU32 rowColor = 0;
      if( packetSet )
      {
        rowColor = getPacketSetColor( packet->packetSetId, packetSet->direction, consecutiveCount );
      }

      if( isSelected )
      {
        // Darken the color for selected row
        rowColor = ( rowColor & 0xFF000000 ) | ( ( rowColor & 0xFEFEFE ) >> 1 );
      }

      if( rowColor != 0 )
      {
        ImGui::TableSetBgColor( ImGuiTableBgTarget_RowBg0, rowColor );
      }

      ImGui::PushID( static_cast< int >( i ) );

      // Direction column
      ImGui::TableSetColumnIndex( 0 );
      if( packetSet )
      {
        ImVec4 directionColor;
        switch( packetSet->direction )
        {
          case 0: directionColor = ImVec4( 0.2f, 0.8f, 0.2f, 1.0f );
            break;
          case 1: directionColor = ImVec4( 0.8f, 0.2f, 0.2f, 1.0f );
            break;
          case 3: directionColor = ImVec4( 0.2f, 0.4f, 0.8f, 1.0f );
            break;
          case 4: directionColor = ImVec4( 0.6f, 0.6f, 0.6f, 1.0f );
            break;
          default: directionColor = ImVec4( 1.0f, 1.0f, 1.0f, 1.0f );
            break;
        }

        if( ImGui::Selectable( getDirectionIcon( packetSet->direction ), isSelected,
                               ImGuiSelectableFlags_SpanAllColumns ) )
        {
          m_selectedPacketIdx = i;
        }

        // Right-click context menu for packet export
        if( ImGui::BeginPopupContextItem() )
        {
          if( ImGui::MenuItem( "Export Packet as Binary" ) )
          {
            exportPacketAsBinary( packet );
          }

          if( ImGui::MenuItem( "Export Packet Set as Binary" ) )
          {
            exportPacketSetAsBinary( packetSet );
          }

          ImGui::EndPopup();
        }
      }
      else
      {
        if( ImGui::Selectable( "?", isSelected, ImGuiSelectableFlags_SpanAllColumns ) )
        {
          m_selectedPacketIdx = i;
        }

        // Right-click context menu for packet export (even for unknown packet sets)
        if( ImGui::BeginPopupContextItem() )
        {
          if( ImGui::MenuItem( "Export Packet as Binary" ) )
          {
            exportPacketAsBinary( packet );
          }
          ImGui::EndPopup();
        }
      }

      // Type column
      ImGui::TableSetColumnIndex( 1 );
      ImGui::Text( "%X", packet->packetType );

      // SrcId column
      ImGui::TableSetColumnIndex( 2 );
      if( srcId != 0 )
        ImGui::Text( "%X | %i", srcId, srcId );
      else
        ImGui::Text( "N/A" );

      // Size column
      ImGui::TableSetColumnIndex( 3 );
      ImGui::Text( "%u", packet->packetSize );

      // Timestamp column
      uint32_t packetTimeStamp = packet->packetTimeStamp;
      if( packet->data.size() >= 0x1C )
        packetTimeStamp = *reinterpret_cast< const uint32_t * >( &packet->data[ 0x18 ] );
      ImGui::TableSetColumnIndex( 4 );
      ImGui::Text( "%u", packetTimeStamp );

      // Self column
      ImGui::TableSetColumnIndex( 5 );
      ImGui::Text( "%s", packet->isForSelf ? "Y" : "N" );

      // Comment column
      ImGui::TableSetColumnIndex( 6 );
      ImGui::Text( "%s", packet->comment.c_str() );

      ImGui::PopID(); // Ensure unique ID per row to avoid ID conflicts
    }

    ImGui::EndTable();

    // Debug info below table
    ImGui::Text( "Showing %d / %d packets", visiblePackets, totalPackets );
  }
}

void OldMon::exportPacketAsBinary( const Packet *packet )
{
  if( !packet || packet->data.empty() )
  {
    printf( "Cannot export packet: packet is null or empty\n" );
    return;
  }

  // Generate filename based on packet info
  std::string filename = fmt::format( "packet_{}_{:04X}_{}.bin",
                                      packet->id,
                                      packet->packetType,
                                      packet->packetTimeStamp );

  // Create the binary data with 0x18 00 bytes prefix
  std::vector< uint8_t > binaryData;

  // Add 0x18 (24) null bytes at the beginning
  binaryData.resize( 0x18, 0x00 );

  // Append the original packet data
  binaryData.insert( binaryData.end(), packet->data.begin(), packet->data.end() );

  // Write to file
  std::ofstream outFile( filename, std::ios::binary );
  if( !outFile.is_open() )
  {
    printf( "Failed to create file: %s\n", filename.c_str() );
    return;
  }

  outFile.write( reinterpret_cast< const char * >( binaryData.data() ), binaryData.size() );
  outFile.close();

  if( outFile.good() )
  {
    printf( "Successfully exported packet to: %s (size: %zu bytes, original: %zu + 24 prefix)\n",
            filename.c_str(), binaryData.size(), packet->data.size() );
  }
  else
  {
    printf( "Error writing to file: %s\n", filename.c_str() );
  }
}

void OldMon::exportPacketSetAsBinary( const PacketSet *packetSet )
{
  if( !packetSet || packetSet->packets.empty() )
  {
    printf( "Cannot export packet set: packet set is null or empty\n" );
    return;
  }

  // Generate filename based on packet set info
  std::string filename = fmt::format( "packetset_{}_{}_dir{}_{}_packets.bin",
                                      packetSet->id,
                                      packetSet->captureId,
                                      packetSet->direction,
                                      packetSet->packets.size() );

  // Create the binary data
  std::vector< uint8_t > binaryData;

  // Calculate total size needed (24 prefix bytes + all packet data)
  size_t totalSize = 0x18; // 24 prefix bytes at the top
  for( const auto& packet : packetSet->packets )
  {
    totalSize += packet.data.size();
  }

  // Reserve space for better performance
  binaryData.reserve( totalSize );

  // Add 0x18 (24) null bytes at the beginning of the file (only once)
  for( int i = 0; i < 0x18; ++i )
  {
    binaryData.push_back( 0x00 );
  }

  // Add each packet data one after another (no additional prefixes)
  for( const auto& packet : packetSet->packets )
  {
    binaryData.insert( binaryData.end(), packet.data.begin(), packet.data.end() );
  }

  // Write to file
  std::ofstream outFile( filename, std::ios::binary );
  if( !outFile.is_open() )
  {
    printf( "Failed to create file: %s\n", filename.c_str() );
    return;
  }

  outFile.write( reinterpret_cast< const char * >( binaryData.data() ), binaryData.size() );
  outFile.close();

  if( outFile.good() )
  {
    printf( "Successfully exported packet set to: %s\n", filename.c_str() );
    printf( "  - Packet Set ID: %u (Direction: %u)\n", packetSet->id, packetSet->direction );
    printf( "  - Total packets: %zu\n", packetSet->packets.size() );
    printf( "  - Total file size: %zu bytes\n", binaryData.size() );

    // Calculate original data size (without prefix)
    size_t originalDataSize = 0;
    for( const auto& packet : packetSet->packets )
    {
      originalDataSize += packet.data.size();
    }
    printf( "  - Original data size: %zu bytes (+ 24 prefix bytes)\n", originalDataSize );
  }
  else
  {
    printf( "Error writing to file: %s\n", filename.c_str() );
  }
}

ImU32 OldMon::getPacketSetColor( uint32_t packetSetId, uint8_t direction, size_t consecutiveIndex )
{
  // Base colors for different directions
  uint8_t baseR, baseG, baseB;

  switch( direction )
  {
    case 3: // Blueish tint
      baseR = 100;
      baseG = 150;
      baseB = 255;
      break;
    case 4: // Greyish tint
      baseR = 180;
      baseG = 180;
      baseB = 180;
      break;
    default:
      // For other directions, generate color based on packet set ID
    {
      uint32_t hash = packetSetId * 0x9E3779B9; // Golden ratio hash
      baseR = ( ( hash >> 16 ) & 0xFF ) | 0x80; // Ensure reasonable brightness
      baseG = ( ( hash >> 8 ) & 0xFF ) | 0x80;
      baseB = ( hash & 0xFF ) | 0x80;
    }
    break;
  }

  // Apply alternation for consecutive packet sets of the same direction
  if( consecutiveIndex > 0 )
  {
    // Alternate between lighter and darker variants
    float variation = ( consecutiveIndex % 2 == 1 ) ? 0.8f : 1.2f;
    baseR = static_cast< uint8_t >( std::min( 255, static_cast< int >( baseR * variation ) ) );
    baseG = static_cast< uint8_t >( std::min( 255, static_cast< int >( baseG * variation ) ) );
    baseB = static_cast< uint8_t >( std::min( 255, static_cast< int >( baseB * variation ) ) );
  }

  // Make colors more pastel by mixing with white
  baseR = ( baseR + 255 ) / 2;
  baseG = ( baseG + 255 ) / 2;
  baseB = ( baseB + 255 ) / 2;

  return IM_COL32( baseR, baseG, baseB, 80 ); // Moderate alpha for background
}

const char *OldMon::getDirectionIcon( uint8_t direction )
{
  switch( direction )
  {
    case 0: return "IN"; // Incoming/Server to Client
    case 1: return "OUT"; // Outgoing/Client to Server
    case 3: return "IN"; // Direction 3 - diamond shape
    case 4: return "OUT"; // Direction 4 - square shape
    default: return "?";
  }
}

const Version *OldMon::getSelectedVersion() const
{
  if( m_selectedVersionIdx < m_versions.size() )
    return &m_versions[ m_selectedVersionIdx ];
  return nullptr;
}

Capture *OldMon::getSelectedCapture()
{
  if( m_selectedCaptureIdx < m_captures.size() )
    return &m_captures[ m_selectedCaptureIdx ];
  return nullptr;
}
